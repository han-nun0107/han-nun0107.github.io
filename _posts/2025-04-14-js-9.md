---
title: "JavaScript 스코프 체인, 호이스팅, 클로저, 렉시컬 스코프"
excerpt: "자바스크립트 실행 컨텍스트의 핵심인 스코프 체인, 호이스팅, 클로저, 렉시컬 스코프를 실제 예제와 함께 설명합니다."

categories:
  - VanillaJS
tags:
  - [VanillaJS, 스코프 체인, 호이스팅, 클로저, 렉시컬 스코프]

permalink: /categories3/VanillaJS-9/

toc: true
toc_sticky: true

date: 2025-04-13
last_modified_at: 2025-04-13
---

## 🦥 본문

---

## 🧠 JavaScript 스코프 체인, 호이스팅, 클로저, 렉시컬 스코프 정리

```js
//스코프 체인과 호이스팅
function a() {
  console.log(b);
  var b = "bbb";
  console.log(b);

  function b() {
    console.log(b);
  }
}
a();
//함수 선언이 변수 선언보다 우선 순위가 높게 호이스팅이 됌.
//따라서 함수 b의 선언이 변수 b의 선언보다 먼저 처리가 됨
console.log("--------------------------");
function b() {
  function c() {
    console.log(c);
  }
  var c;

  console.log(c);
  c = "bbb";
  console.log(c);
}
b();
console.log("--------------------------");
console.log(sum(1, 3)); // -> 4출력
function sum(a, b) {
  return a + b;
  //함수 전체가 호이스팅 > 코드 어디서든 호출이 가능
}
// console.log(multiply(2, 3)); -> undefined

var multiply = function (a, b) {
  return a * b;
  //변수 이름만 호이스팅 할당 이후에만 호출 가능
};
console.log(multiply(2, 3)); //-> 6 출력

console.log("--------------------------");
console.log("클로저");

// 클로저
//클로저는 함수와 그 함수가 선언될 당시의 렉시컬 환경(lexical environment)의 상호관계에 따른 현상

var closor = function () {
  var a = 1;
  var inner = function () {
    console.log(++a);
  };
  inner();
};
closor();

// [생명주기 1단계: 전역 생성 단계]
const v = 1;

function closorLex() {
  // [생명주기 2단계: 함수 호출 및 실행 컨텍스트 생성]
  const v = 10;

  const inner = function () {
    // [실행 시점: inner 함수 호출 시점]
    console.log(v); // closorLex의 v (값: 10)를 출력
  };

  // [생명주기 3단계: 함수 종료 및 클로저 형성]
  return inner;
}

// [생명주기 4단계: 클로저 생성 후 전역에 저장]
const innerFunc = closorLex();

// [생명주기 5단계: 클로저 실행]
innerFunc(); // 출력: 10

console.log("--------------------------");
console.log("블록 렉시컬");

function createFunc() {
  {
    let y = 20;
    var innerFunc = function () {
      console.log(y);
    };
    return innerFunc;
  }
}

const myFunc = createFunc();
myFunc(); // 출력: 20
console.log("--------------------------");

//렉시컬 스코프와 스코프 체인
var x = "전역 변수 x";

function outer() {
  var y = "외부 변수 y";

  function inner() {
    var z = "내부 변수 z";

    console.log("z:", z); // 출력: 내부 변수 z
    console.log("y:", y); // 출력: 외부 변수 y
    console.log("x:", x); // 출력: 전역 변수 x
  }

  inner();
}
outer();
console.log("--------------------------");
```

---

## ✅ 추가 설명 정리

- **호이스팅**: 함수 선언은 전체가 끌어올려지고, 변수는 선언만 호이스팅됩니다.
- **클로저**: 함수가 선언될 당시의 렉시컬 환경을 기억하며, 외부 함수의 지역 변수에 접근 가능합니다.
- **렉시컬 스코프**: 변수 참조는 코드 작성 시의 스코프 기준으로 결정됩니다.
- **스코프 체인**: 함수 실행 시 내부 → 외부 → 전역 순으로 변수 검색이 진행됩니다.

---

## 📊 핵심 개념 요약 (표 형식)

| 개념                 | 설명                                                                                     |
| -------------------- | ---------------------------------------------------------------------------------------- |
| 🔁 **호이스팅**      | 변수와 함수 선언이 코드 실행 전에 메모리에 등록됨. 함수는 전체, 변수는 선언만 호이스팅됨 |
| 🔗 **스코프 체인**   | 실행 시 변수 탐색을 현재 → 부모 → 전역 스코프로 이동하며 검색                            |
| 📦 **클로저**        | 함수가 선언될 당시의 렉시컬 환경을 기억하여 외부 변수에 접근할 수 있는 함수              |
| 🧭 **렉시컬 스코프** | 함수의 실행 위치가 아닌 정의된 위치에 따라 참조 스코프가 결정됨                          |

---
